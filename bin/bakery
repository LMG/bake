#!/usr/bin/env ruby

$timeStart = Time.now

$:.unshift(File.dirname(__FILE__)+"/../lib")
require 'common/version'

require 'imported/utils/utils'

puts "-- bakery #{Bake::Version.number}, ruby #{RUBY_VERSION}p#{RUBY_PATCHLEVEL}, platform #{RUBY_PLATFORM} --"

STDOUT.sync = true
STDERR.sync = true

require 'bake/toolchain/colorizing_formatter'
require 'tocxx'
require "bakery/model/loader"
require "bakery/options/options"
require "bakery/toBake"
require "bakery/buildPattern"
require 'imported/ext/stdout'
require 'common/cleanup'

module Bake
 
  @options = BakeryOptions.new(ARGV)
  @options.parse_options

  env = nil
  begin
    loader = BakeryLoader.new 
    env = loader.load(@options.collection_dir+"/Collection.meta")
  rescue Exception => e
    puts e
    puts e.backtrace
    ExitHelper.exit(1)
  end 

  
  if @options.collection_name.empty? 
    puts "Please specify a collection name (with -b). Possible values are:"      
    env.find(:class => BakeryModel::Collection).each { |e|
      puts "* " + e.name
    }
    ExitHelper.exit(0)
  end


  def self.getCollections(env, name)
    cols = env.find(:class => BakeryModel::Collection, :name => name)
    @toBuild |= getBuildPattern(cols, name)
    @colsAll |= cols
    cols[0].collections.each do |cRef|
      alreadyProcessed = false
      @colsAll.each do |ca|
        alreadyProcessed = true if ca.name == cRef.name 
      end
      getCollections(env, cRef.name) unless alreadyProcessed
    end
  end  
  
  @toBuild = []
  @colsAll = []
  getCollections(env, @options.collection_name)
  
  maxRuns = @toBuild.length
  currentRun = 0
  failedRuns = 0
  
  passedParams = []
  excludeParam = false
  ARGV.each do |x|
    if (x=="-b" or x=="-m" or x=="-p" or x=="-e" or x=="--socket")
      excludeParam = true
      next
    end
    if excludeParam
      excludeParam = false
      next
    end
    passedParams << x
  end  
  
  if @options.socket != 0
    Bake::IDEInterface.instance.connect(@options.socket)
  end

  msg1 = "* bakery "

  exitValue = 0
  abort = false
  @toBuild.each do |bp|
    currentRun += 1
    p = File.dirname(bp.proj)
    cmd = (["-m", p, "-b", bp.conf] + passedParams)
    cmdWithNum = "* bakery #{currentRun} of #{maxRuns}: bake " + cmd.join(" ") + " *"
    print "\n"; cmdWithNum.length.times { print "*" }; print "\n";
    Bake.formatter.printInfo cmdWithNum
    cmdWithNum.length.times { print "*" }; print "\n";
    
    runOk = false
    begin
      Bake.options = Options.new(cmd)
      Bake.options.parse_options
      tocxx = ToCxx.new
      tocxx.doit()
      runOk = ExitHelper.exit_code == 0
    rescue Exception => e
      puts e.message if not e.class === SystemExit 
    end
    
    Bake::cleanup
    ExitHelper.reset_exit_code
      
    if runOk == false
      exitValue = 1
      failedRuns += 1
      if @options.error
        msg1 << "aborted, "
        abort = true
        break
      end
    end
  end
  
  print "\n"

  if not abort
    if failedRuns > 0
      msg1 << "summary: #{failedRuns} of #{maxRuns} builds failed, "
    else
      msg1 << "summary: #{maxRuns-failedRuns} of #{maxRuns} builds ok, "
    end
  else
  end

  timeEnd = Time.now
  timeDiff = timeEnd - $timeStart
  msg1 << "time: %02d:%02d minutes *" % [timeDiff/60, timeDiff%60]
  
  stars = ""
  msg1.length.times { stars << "*" }

  if failedRuns == 0
    Bake.formatter.printSuccess stars
    Bake.formatter.printSuccess msg1
    Bake.formatter.printSuccess stars
  else
    Bake.formatter.printError stars
    Bake.formatter.printError msg1
    Bake.formatter.printError stars
  end
  
  Bake::IDEInterface.instance.disconnect()

  ExitHelper.exit(exitValue)
end

