#!/usr/bin/env ruby

$timeStart = Time.now

$:.unshift(File.dirname(__FILE__)+"/../lib")
require 'bake/version'

$:.unshift(File.dirname(__FILE__)+"/../../cxxproject_master.git/lib")

require "cxxproject/version"

puts "-- bakery #{Cxxproject::Version.bake}, ruby #{RUBY_VERSION}p#{RUBY_PATCHLEVEL}, platform #{RUBY_PLATFORM} --"

STDOUT.sync = true
STDERR.sync = true

require 'cxxproject/utils/printer'
require 'tocxx'
require "bakery/loader"
require "bakery/options"
require "bakery/toBake"
require "bakery/buildPattern"
require 'cxxproject/ext/stdout'
require 'cxxproject/utils/cleanup'

module Cxxproject

 
  @options = BakeryOptions.new(ARGV)
  @options.parse_options

  env = nil
  begin
    loader = BakeryLoader.new(@options) 
    env = loader.load(@options.collection_dir+"/Collection.meta")
  rescue Exception => e
    ExitHelper.exit(1)
  end 

  
  if @options.collection_name.empty? 
    puts "Please specify a collection name (with -b). Possible values are:"      
    env.find(:class => BakeryModel::Collection).each { |e|
      puts "* " + e.name
    }
    ExitHelper.exit(0)
  end


  def self.getCollections(env, name)
    cols = env.find(:class => BakeryModel::Collection, :name => name)
    @toBuild |= getBuildPattern(cols, name)
    @colsAll |= cols
    cols[0].collections.each do |cRef|
      alreadyProcessed = false
      @colsAll.each do |ca|
        alreadyProcessed = true if ca.name == cRef.name 
      end
      getCollections(env, cRef.name) unless alreadyProcessed
    end
  end  
  
  @toBuild = []
  @colsAll = []
  getCollections(env, @options.collection_name)
  
  maxRuns = @toBuild.length
  currentRun = 0
  failedRuns = 0
  
  passedParams = []
  excludeParam = false
  ARGV.each do |x|
    if (x=="-b" or x=="-m" or x=="-p" or x=="-e" or x=="--socket")
      excludeParam = true
      next
    end
    if excludeParam or x == @options.collection_name
      excludeParam = false
      next
    end
    passedParams << x
  end  
  
  if @options.socket != 0
    Rake.application.idei.connect(@options.socket)
  end

  msg1 = "* bakery "

  ExitHelper.enable_exit_test
  
  exitValue = 0
  abort = false
  @toBuild.each do |bp|
    currentRun += 1
    p = File.dirname(bp.proj)
    cmd = (["-m #{p} -b #{bp.conf}"] + passedParams).join(" ")
    cmdWithNum = "* bakery #{currentRun} of #{maxRuns}: bake " + cmd + " *"
    print "\n"; cmdWithNum.length.times { print "*" }; print "\n";
    Printer.printInfo cmdWithNum
    cmdWithNum.length.times { print "*" }; print "\n";
    
    runOk = true
    begin
      bakeOptions = Options.new(cmd.split(" "))
      bakeOptions.parse_options
      tocxx = ToCxx.new(bakeOptions)
      if tocxx.doit()
        runOk = tocxx.start()
      else
        runOk = false
      end
    rescue
      runOk = false
    end
    
    Utils.cleanup_rake
    ExitHelper.reset_exit_code
      
    if runOk == false
      exitValue = 1
      failedRuns += 1
      if @options.error
        msg1 << "aborted, "
        abort = true
        break
      end
    end
  end
  
  print "\n"

  if not abort
    if failedRuns > 0
      msg1 << "summary: #{failedRuns} of #{maxRuns} builds failed, "
    else
      msg1 << "summary: #{maxRuns-failedRuns} of #{maxRuns} builds ok, "
    end
  else
  end

  timeEnd = Time.now
  timeDiff = timeEnd - $timeStart
  msg1 << "time: %02d:%02d minutes *" % [timeDiff/60, timeDiff%60]
  
  stars = ""
  msg1.length.times { stars << "*" }

  if failedRuns == 0
    Printer.printSuccess stars
    Printer.printSuccess msg1
    Printer.printSuccess stars
  else
    Printer.printError stars
    Printer.printError msg1
    Printer.printError stars
  end
  
  Rake.application.idei.disconnect()

  ExitHelper.disable_exit_test
  ExitHelper.exit(exitValue)
end

